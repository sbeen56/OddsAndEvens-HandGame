package nz.ac.auckland.se281;

import nz.ac.auckland.se281.Main.Choice;

/**
 * This class implements the ArtIntPlayer interface. This class represents the hard AI player that
 * switches between the top and random strategy.
 */
public class HardArtIntPlayer implements ArtIntPlayer {
  private Strategy strategy;
  private String ai = "HAL-9000";
  private Choice choice;
  private int finger;

  /**
   * This method sets the strategy for the AI player.
   *
   * @param strategy strategy to be set
   */
  @Override
  public void setStrategy(Strategy strategy) {
    this.strategy = strategy;
  }

  /**
   * This method sets the choice of the AI player.
   *
   * @param choice choice from the human player
   */
  @Override
  public void setArtIntPlayer(Choice choice) {
    switch (choice) {
      case EVEN:
        this.choice =
            Choice.ODD; // Set the choice of the AI player to ODD when the human player chooses EVEN
        break;

      case ODD:
        this.choice =
            Choice
                .EVEN; // Set the choice of the AI player to EVEN when the human player chooses ODD
        break;

      default:
        break;
    }
  }

  /**
   * This method generates a finger for the AI player. It uses the random strategy to generate a
   * finger for the first 3 rounds. After that, it switches between the top and random strategy
   * based on the winner of the previous round.
   *
   * @param winner winner of the previous round
   * @param round round of the game
   * @param oddCount number of odd numbers of human player
   * @param evenCount number of even numbers of human player
   * @return int finger generated by the AI player
   */
  @Override
  public int makeMove(String winner, int round, int oddCount, int evenCount) {
    if (round < 4) {
      setStrategy(new RandomStrategy()); // Set the strategy to random for the first 3 rounds
    } else {
      // Switch between top and random strategy based on the winner of the previous round
      if (!winner.equals("HAL-9000")) {
        if (strategy instanceof RandomStrategy) {
          setStrategy(new TopStrategy()); // Set the strategy to top if strategy was random before.
        } else {
          setStrategy(
              new RandomStrategy()); // Set the strategy to random if strategy was top before.
        }
      }
    }

    // Generate a finger using the strategy and save it in the finger variable.
    this.finger = strategy.play(round, oddCount, evenCount, choice);
    return finger;
  }

  /**
   * This method returns the saved finger generated by the AI player. This method does not generate
   * a new finger. It can be used after the makeMove method has been called. It is used to calculate
   * the sum of fingers of the AI player and the human player.
   *
   * @return int finger generated by the AI player
   */
  @Override
  public int getMove() {
    return finger;
  }

  /**
   * This method returns the choice of the AI player. It returns the opposite choice of the human
   * player. This can be used after the human player has made a choice and the setArtIntPlayer
   * method has been called.
   *
   * @return Choice choice of the AI player
   */
  @Override
  public Choice getArtIntChoice() {
    return choice;
  }

  /**
   * This method returns the name of the AI player. The name of the AI player is fixed as HAL-9000.
   * So this method returns HAL-9000. This can be used to print the name of the AI player. It can be
   * called as soon as the AI player is created.
   *
   * @return String name of the AI player
   */
  @Override
  public String getArtIntName() {
    return ai;
  }

  /** This method prints the move of the AI player. */
  @Override
  public void printMove() {
    MessageCli.PRINT_INFO_HAND.printMessage(ai, Integer.toString(finger));
  }
}
